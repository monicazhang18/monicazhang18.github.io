---
title: Knuth-Morris-Pratt (KMP) Algorithm
description: Algorithm for pattern matching
author: yoyo
date: 2024-08-08 17:18:00 +0800
categories: [Data Structure and Algorithm, Algorithm]
tags: [kmp]
---

## String-matching algorithm

A string-matching algorithm wants to find the starting index `m` in string `s` that matches the search word `w`.[^wiki] This process is foundational in text processing and computer science applications such as text editing and data retrieval.

**Example**
  - `s = "ABCABABCABDA"`
  - `w "ABCABD"`

### Brute force solution

The brute force approach employs a straightforward method using two pointers: one traverses the main string `s` and the other checks against the target word `w`. For each character in `s`, it compares the subsequent characters up to the length of `w`. If a mismatch occurs, the pointer in `s` moves to the next character, and the comparison begins anew.

![Desktop View](/assets/image/algorithm/kmp/string-matching-algorithm-1.jpeg){: .normal }

However, this approach has a time complexity of `O(mn)`, where `m = len(s)` and `n = len(w)`. This method can become extremely inefficient, especially when mismatches consistently occur near the end of` w` and when `w` itself appears late in `s`. For example, consider `s = "000000000000000000001"` and `w = "00000001"`. In this scenario, nearly every attempt will process almost the entire length of `w` before encountering a mismatch, leading to significant redundancy in the search process.

![Desktop View](/assets/image/algorithm/kmp/string-matching-algorithm-2.jpeg){: .normal }

### The advantage of KMP

The **<ins>Knuth-Morris-Pratt (KMP)</ins>** algorithm enhances efficiency through the use of a **<ins>Prefix Table</ins>** (aka. **<ins>"Partial Match" Table</ins>**[^wiki]) `next`. This table allows the algorithm to skip over sections of `s` that have previously been matched against parts of `w`, avoiding re-evaluation of characters that will anyway match according to the prefix table.

![Desktop View](/assets/image/algorithm/kmp/string-matching-algorithm-3.jpeg){: .normal }

## How KMP works

### Prefixes and Suffixes
  - **Prefix Table**:
    - This table is constructed from the search word `w` and records the length of the longest prefix which is also a suffix for the substring ending at each index `i` (inclusive).
    - **Prefix**:
      - A prefix of a string is any substring that <ins>starts at the beginning of the string</ins> and <ins>does not include the last character</ins> of the string. These are all possible leading segments of the string.
    - **Suffix**:
      - A suffix of a string is any substring that <ins>ends at the end of the string</ins> and <ins>does not include the first character</ins> of the string. These are all possible ending segments of the string[^dmsxl].

![Desktop View](/assets/image/algorithm/kmp/how-kmp-works-1.jpeg){: .normal } 

According to the prefix table `next`, when match between `s` and `w` fail at `w[i]` we can avoid the redundence searching by directly skip to the next possible match position `next[i]`.

For each `next[i]` it record the longest prefix of `w` that matches a suffix ending just before `w[i]`. Instead of restarting the search from the next character in s, a prefix table `next` allows us to jump to `w[next[i]]`, effectively bypassing the redundant re-checking of characters that are guaranteed to match based on previous comparisons. 

### Preprocessing: Create a prefix table


### Searching: Align to the next potential match

## Complexity

### Complexity of preprocessing

### Complexity of searching

## The code

### Python

### C


## Reference

[^wiki]: Wikipedia - Knuth–Morris–Pratt algorithm:[https://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm](https://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm).
[^dmsxl]: 代码随想录: [https://programmercarl.com/0028.实现strStr.html#思路](https://programmercarl.com/0028.实现strStr.html#思路)

